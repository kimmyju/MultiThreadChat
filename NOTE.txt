1. 빌드 및 실행 코드
(1) 서버: 
gcc -o server server.c -pthread
./server [ip] [포트번호]

(2) 클라이언트: 
gcc -o client client.c -pthread
./client [포트번호]
--> 본인은 편리한 테스를 위해 client1 과 client2 총 두개의 실행 파일로 코드 테스트를 진행함.
----------------------------------------------------------------------------------------
2. server.c의 함수 기능 목록
(1) 메인 함수 (main())
# 기능
서버 초기화 및 설정
클라이언트 연결 수락
클라이언트 핸들러 스레드 생성

#알고리즘
서버 소켓 생성 및 바인딩
무한 루프를 통해 클라이언트 연결 수락

(2) 클라이언트 핸들러 (handle_client())
# 기능
클라이언트 메시지 처리
클라이언트 접속 및 종료 알림
클라이언트 메시지 브로드캐스트

# 알고리즘
클라이언트 닉네임 수신 및 접속 알림
메시지 수신 및 처리
클라이언트 종료 처리

(3) 메시지 브로드캐스트 (send_message_to_all())
# 기능
특정 클라이언트를 제외한 모든 클라이언트에게 메시지 전송

# 알고리즘
모든 클라이언트에게 메시지 전송

(4) 클라이언트 상태 알림 (notify_client_status())
# 기능
모든 클라이언트에게 상태 메시지 브로드캐스트

# 알고리즘
모든 클라이언트에게 상태 메시지 전송
----------------------------------------------------------------------------------------
3. client.c의 함수 기능 목록
(1) 메인 함수 (main())
# 기능
서버와의 연결 설정
사용자 닉네임 입력 및 서버로 전송
사용자 입력 처리 및 서버로 메시지 전송
수신 스레드 생성

# 알고리즘
소켓 생성 및 서버 연결
사용자 닉네임 입력 및 서버로 전송
사용자 입력 처리 및 메시지 전송
수신 스레드 생성

(2) 수신 스레드 함수 (my_thread())
# 기능
서버로부터 메시지 수신 및 출력
서버와의 연결 종료 처리

# 알고리즘
서버로부터 read를 통해 메시지 수신 및 출력
서버와의 연결 종료 처리 즉 리소스 해제 및 스레드 종료
----------------------------------------------------------------------------------------

4. 핵심 알고리즘 및 비동기 처리
(1) 멀티스레딩을 통한 독립적인 송수신
# 서버 측
클라이언트 핸들러 스레드: 각 클라이언트는 독립적인 스레드에서 처리되도록 구성. 이를 통해 여러 클라이언트가 동시에 연결되어도 각 클라이언트의 메시지 송수신이 독립적으로 이루어질 수 있도록 함.
--> pthread_create(&client->thread, NULL, handle_client, (void*)client);

# 클라이언트 측
수신 스레드: 클라이언트가 별도의 수신 스레드를 가지도록 하고, 이를 통해 서버로부터 수신한 메시지를 비동기적으로 처리하도록 함. 이를 통해 사용자가 메시지를 입력하는 동안에도 서버로부터의 메시지를 실시간으로 받을 수 있도록 함.
--> pthread_create(&tid, NULL, my_thread, &fd);
----------------------------------------------------------------------------------------

5. 기존 client.c 변경 부분
(1) 닉네임을 입력하고 서버로 전송하는 부분 추가
(2) 기존의 scanf("%s", buf);에서 scanf("%[^\n]", buf);로 변경하여 공백을 포함한 입력을 처리하도록 하였으며,
scanf("%*c");를 추가하여 입력 버퍼를 비우도록 했음. 이는 줄바꿈 문자(\n)를 제거하여 다음 입력에 영향을 미치지 않도록 하기 위함.

